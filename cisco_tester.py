import requests
from datetime import datetime
import csv
import argparse
from pathlib import Path


def check_host(ip_address: str,
               secure: bool = False) -> dict:
    scheme = "https" if secure else "http"
    url = f"{scheme}://{ip_address}/webui/logoutconfirm.html?logon_hash=1"

    try:
        response = requests.post(url, timeout=5, verify=False)
    except requests.exceptions.Timeout:
        return format_event(ip_address, scheme, 'No Detection')

    except Exception as e:
        return format_event(ip_address, scheme,  f'Error: {str(e)}')

    if '1a80b7389ccd0a5dab' in response.text:
        return format_event(ip_address, scheme, 'Implant Detected: CVE-2023-20198')
    else:
        return format_event(ip_address, scheme, 'No Detection')


def format_event(ip: str,
                 scheme: str,
                 status: str) -> dict:
    event = {'Timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
             'IP Address': ip,
             'Scheme': scheme,
             'Status': status}

    return event


def write_to_csv(output_data: list,
                 result_file_name: str = 'scan_results.csv',
                 overwrite_output_file: bool = False) -> None:
    if overwrite_output_file:
        file_method = 'w'
    else:
        file_method = 'a'

    # Find out if the result file already exists
    result_file_exists = Path(result_file_name).exists()

    with open(result_file_name, file_method, newline='') as csvfile:
        fieldnames = ['Timestamp', 'IP Address', 'Scheme', 'Status']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        # If it is a new file, write the header
        if not result_file_exists:
            writer.writeheader()

        # Iterate through the event dicts and write them to the CSV
        for event in output_data:
            writer.writerow(event)

    print(f'\nResults saved to: {result_file_name} ')


def read_file(file: str) -> list:
    lines = []
    with open(file) as f:
        for line in f:
            lines.append(line.strip())

    return lines


def scan_and_report(ip_list: list,
                    secure: bool = False,
                    result_file_name: str = 'scan_results.csv',
                    overwrite_output_file: bool = False) -> None:
    results = []
    for ip in ip_list:
        result = check_host(ip, secure)
        print(result)
        results.append(result)

    write_to_csv(results,
                 result_file_name=result_file_name,
                 overwrite_output_file=overwrite_output_file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Implant Detection for Cisco vulnerability (CVE-2023-20198)')
    parser.add_argument('-i', '--input_file',
                        required=False,
                        help='Filename for input list of IPs')

    parser.add_argument('--secure',
                        action='store_true',
                        default=False,
                        help='Set this to enable HTTPS connections')

    parser.add_argument('--result_file',
                        default='scan_results.csv',
                        help='The name of the output_data file')

    parser.add_argument('--overwrite',
                        dest='overwrite_output_file',
                        action='store_true',
                        default=False,
                        help='Write behaviour of the output file. Append or overwrite.  Append is default.')

    args = parser.parse_args()
    if not args.input_file:
        ip_addresses = input("Enter comma-separated IP addresses: ").split(',')
        ip_addresses = [ip.strip() for ip in ip_addresses]  # Remove any extra spaces
    else:
        ip_addresses = read_file(args.input_file)

    # execute the main scan and report function
    scan_and_report(ip_addresses,
                    secure=args.secure,
                    result_file_name=args.result_file,
                    overwrite_output_file=args.overwrite_output_file)
